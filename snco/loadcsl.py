'''functions for converting cellsnp-lite output into snco.MarkerRecords format'''
import os
import logging
from dataclasses import dataclass
from scipy.io import mmread

import pysam

from .utils import read_cb_whitelist
from .records import MarkerRecords
from .clean import filter_low_coverage_barcodes

log = logging.getLogger('snco')


def read_chrom_sizes(chrom_sizes_fn):
    '''
    load dict of chromosome lengths from a 2 column text file or faidx file
    '''
    chrom_sizes = {}
    with open(chrom_sizes_fn) as f:
        for record in f:
            chrom, cs = record.strip().split('\t')[:2]
            chrom_sizes[chrom] = int(cs)
    return chrom_sizes


def parse_sample_alleles(variant):
    if len(variant.alleles) != 2:
        raise ValueError('Only biallelic variants are allowed')
    ref_samples = set()
    alt_samples = set()
    for sample_id, sample in variant.samples.items():
        if len(sample.alleles) > 1:
            raise ValueError('Only haploid haplotype calls are allowed for each sample')
        if not sample.allele_indices[0]:
            ref_samples.add(sample_id)
        else:
            alt_samples.add(sample_id)
    return ref_samples, alt_samples


class VariantRecords:

    def __init__(self):
        self._records = []
        self._samples = {}

    def add(self, contig, pos, sample_alleles=None):
        self._records.append((contig, pos))
        self._samples[(contig, pos)] = sample_alleles

    def __getitem__(self, index):
        return self._records[index]

    def get_samples(self, contig, pos):
        return self._samples[(contig, pos)]


def read_vcf(vcf_fn, drop_samples=True):
    with pysam.VariantFile(vcf_fn, drop_samples=drop_samples) as vcf:
        variants = VariantRecords()
        for record in vcf.fetch():
            if drop_samples:
                sample_alleles = None
            else:
                try:
                    sample_alleles = parse_sample_alleles(record)
                except ValueError:
                    continue
            variants.add(record.contig, record.pos, sample_alleles)
    return variants


def parse_cellsnp_lite(csl_dir, validate_barcodes=True):
    '''
    read data from cellsnp-lite output into a MarkerRecords object
    '''
    dep_fn = os.path.join(csl_dir, 'cellSNP.tag.DP.mtx')
    alt_fn = os.path.join(csl_dir, 'cellSNP.tag.AD.mtx')
    vcf_fn = os.path.join(csl_dir, 'cellSNP.base.vcf')
    if not os.path.exists(vcf_fn):
        vcf_fn = f'{vcf_fn}.gz'
    barcode_fn = os.path.join(csl_dir, 'cellSNP.samples.tsv')

    dep_mm = mmread(dep_fn)
    alt_mm = mmread(alt_fn).tocsr()
    barcodes = read_cb_whitelist(barcode_fn, validate_barcodes=validate_barcodes)
    variants = read_vcf(vcf_fn)

    return dep_mm, alt_mm, barcodes, variants


@dataclass(frozen=True)
class SNPCounts:
    cb: str
    chrom: str
    pos: int
    ref_count: int
    alt_count: int
    ref_samples: set = None
    alt_samples: set = None


def iter_cellsnp_lite_markers(csl_dir, cb_whitelist,
                              sample_vcf_fn=None,
                              validate_barcodes=True):
    dep_mm, alt_mm, barcodes, variants = parse_cellsnp_lite(
        csl_dir, validate_barcodes=validate_barcodes
    )
    if sample_vcf_fn is not None:
        sample_alleles = read_vcf(sample_vcf_fn, drop_samples=False)
    else:
        sample_alleles = None
    for cb_idx, var_idx, tot in zip(dep_mm.col, dep_mm.row, dep_mm.data):
        cb = barcodes[cb_idx]
        if cb in cb_whitelist:
            alt = alt_mm[var_idx, cb_idx]
            ref = tot - alt
            chrom, pos = variants[var_idx]
            if sample_alleles is None:
                yield SNPCounts(cb, chrom, pos, ref, alt)
            else:
                ref_samples, alt_samples = sample_alleles.get_samples(chrom, pos)
                yield SNPCounts(cb, chrom, pos, ref, alt, ref_samples, alt_samples)


def cellsnp_lite_to_co_markers(csl_dir, chrom_sizes_fn, bin_size, cb_whitelist,
                               validate_barcodes=True):

    chrom_sizes = read_chrom_sizes(chrom_sizes_fn)
    co_markers = MarkerRecords(
        chrom_sizes,
        bin_size,
        seq_type='csl_snps',
    )

    for snp in iter_cellsnp_lite_markers(csl_dir, cb_whitelist,
                                         validate_barcodes=validate_barcodes):
        bin_idx = snp.pos // bin_size
        co_markers[snp.cb, snp.chrom, bin_idx, 0] += snp.ref_count
        co_markers[snp.cb, snp.chrom, bin_idx, 1] += snp.alt_count

    return co_markers


def run_loadcsl(cellsnp_lite_dir, chrom_sizes_fn, output_json_fn, *,
                cb_whitelist_fn=None, bin_size=25_000,
                min_markers_per_cb=100, min_markers_per_chrom=20,
                validate_barcodes=True):
    '''
    Read matrix files generated by cell snp lite to generate a json file of binned
    haplotype marker distributions for each cell barcode. These can be used to
    call recombinations using the downstream `predict` command.
    '''

    cb_whitelist = read_cb_whitelist(cb_whitelist_fn, validate_barcodes=validate_barcodes)
    co_markers = cellsnp_lite_to_co_markers(
        cellsnp_lite_dir,
        chrom_sizes_fn,
        bin_size=bin_size,
        cb_whitelist=cb_whitelist,
        validate_barcodes=validate_barcodes,
    )
    n = len(co_markers)
    log.info(f'Identified {n} cell barcodes from cellsnp-lite files')
    if min_markers_per_cb or min_markers_per_chrom:
        co_markers = filter_low_coverage_barcodes(
            co_markers, min_markers_per_cb, min_markers_per_chrom
        )
        log.info(
            f'Removed {n - len(co_markers)} barcodes with fewer than {min_markers_per_cb} markers'
            f'or fewer than {min_markers_per_chrom} markers per chromosome'
        )
    if output_json_fn is not None:
        log.info(f'Writing markers to {output_json_fn}')
        co_markers.write_json(output_json_fn)
    return co_markers
