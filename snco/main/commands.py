import click
from .opts import snco_opts, sneqtl_opts


@click.group()
@click.version_option()
def main():
    '''
    snco: a toolkit for performing crossover mapping from single nucleus RNA/ATAC sequencing data
    '''
    pass


@main.command('loadbam')
@snco_opts('loadbam')
def loadbam_subcommand(**kwargs):
    '''
    Read bam file with cell barcode, umi and haplotype tags (aligned with STAR solo+diploid), 
    to generate a json file of binned haplotype marker distributions for each cell barcode. 
    These can be used to call recombinations using the downstream `predict` command.
    '''
    from snco.load.commands import run_loadbam
    run_loadbam(**kwargs)


@main.command('loadcsl')
@snco_opts('loadcsl')
def loadcsl_subcommand(**kwargs):
    '''
    Read matrix files generated by cell snp lite to generate a json file of binned
    haplotype marker distributions for each cell barcode. These can be used to
    call recombinations using the downstream `predict` command.
    '''
    from snco.load.commands import run_loadcsl
    run_loadcsl(**kwargs)


@main.command('sim')
@snco_opts('sim')
def sim_subcommand(**kwargs):
    '''
    Simulate realistic haplotype marker distributions using real data from `load`,
    with known haplotypes/crossovers supplied from a bed file.
    '''
    from snco.sim import run_sim
    run_sim(**kwargs)


@main.command('concat')
@snco_opts('concat')
def concat_subcommand(**kwargs):
    '''
    Concatenates marker jsons, potentially from different datasets, 
    adding suffixes to cell barcodes to avoid name collisions
    '''
    from snco.concat import run_concat
    run_concat(**kwargs)


@main.command('clean')
@snco_opts('clean')
def clean_subcommand(**kwargs):
    '''
    Removes predicted background markers, that result from ambient nucleic acids, 
    from each cell barcode.
    '''
    from snco.clean.commands import run_clean
    run_clean(**kwargs)


@main.command('predict')
@snco_opts('predict')
def predict_subcommand(**kwargs):
    '''
    Uses rigid hidden Markov model to predict the haplotypes of each cell barcode
    at each genomic bin.
    '''
    from snco.predict.commands import run_predict
    run_predict(**kwargs)


@main.command('doublet')
@snco_opts('doublet')
def doublet_subcommand(**kwargs):
    '''
    Predict doublets using synthetic doublet detection method
    '''
    from snco.predict.commands import run_doublet
    run_doublet(**kwargs)


@main.command('stats')
@snco_opts('stats')
def stats_subcommand(**kwargs):
    '''
    Scores the quality of data and predictions for a set of haplotype calls
    generated with `predict`.
    '''
    from snco.stats import run_stats
    run_stats(**kwargs)


@main.command('segdist')
@snco_opts('segdist')
def segdist_subcommand(**kwargs):
    '''
    Scores the quality of data and predictions for a set of haplotype calls
    generated with `predict`.
    '''
    from snco.distortion import run_segdist
    run_segdist(**kwargs)


@main.command('plot')
@snco_opts('plot')
def plot_subcommand(**kwargs):
    '''
    Draw a marker plot for a given cell barcode,
    or the recombination landscape of a whole dataset
    '''
    from snco.plot import run_plot
    run_plot(**kwargs)


def _clean_predict_pipeline(co_markers, output_prefix, kwargs):

    from snco.clean.commands import run_clean
    from snco.predict.commands import run_predict

    if kwargs['run_clean']:

        clean_kwargs = snco_opts.get_kwarg_subset('clean', kwargs)
        clean_kwargs['marker_json_fn'] = None
        clean_kwargs['co_markers'] = co_markers
        # filtering already performed in load command
        clean_kwargs['min_markers_per_cb'] = 0
        clean_kwargs['min_markers_per_chrom'] = 0
        clean_kwargs['output_json_fn'] = f'{output_prefix}.markers.json'
        co_markers = run_clean(**clean_kwargs)

    predict_kwargs = snco_opts.get_kwarg_subset('predict', kwargs)
    predict_kwargs['marker_json_fn'] = None
    predict_kwargs['co_markers'] = co_markers
    predict_kwargs['output_json_fn'] = f'{output_prefix}.pred.json'

    run_predict(**predict_kwargs)


@main.command('bam2pred')
@snco_opts('bam2pred')
def bam_pipeline_subcommand(**kwargs):
    '''
    Pipeline chaining together the loadbam, clean and predict commands
    '''
    from snco.load.commands import run_loadbam

    output_prefix = kwargs.pop('output_prefix')
    loadbam_kwargs = snco_opts.get_kwarg_subset('loadbam', kwargs)
    loadbam_kwargs['output_json_fn'] = None
    co_markers = run_loadbam(**loadbam_kwargs)

    _clean_predict_pipeline(co_markers, output_prefix, kwargs)


@main.command('csl2pred')
@snco_opts('csl2pred')
def csl_pipeline_subcommand(**kwargs):
    '''
    Pipeline chaining together the loadcsl, clean and predict commands
    '''
    from snco.load.commands import run_loadcsl

    output_prefix = kwargs.pop('output_prefix')
    loadcsl_kwargs = snco_opts.get_kwarg_subset('loadcsl', kwargs)
    loadcsl_kwargs['output_json_fn'] = None
    co_markers = run_loadcsl(**loadcsl_kwargs)
    _clean_predict_pipeline(co_markers, output_prefix, kwargs)


@click.group()
@click.version_option()
def sneqtl():
    '''
    sneqtl: a toolkit for performing single nucleus eQTL mapping with snco results
    '''
    pass


@sneqtl.command('eqtl')
@sneqtl_opts('eqtl')
def eqtl_subcommand(**kwargs):
    from snco.sneqtl.eqtl import run_eqtl
    run_eqtl(**kwargs)


@sneqtl.command('peakcall')
@sneqtl_opts('peakcall')
def peakcall_subcommand(**kwargs):
    from snco.sneqtl.peaks import run_peakcall
    run_peakcall(**kwargs)