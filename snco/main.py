import logging
import click

from . import logger
from . import opts
from .loadbam import run_loadbam
from .loadcsl import run_loadcsl
from .sim import run_sim
from .concat import run_concat
from .clean import run_clean
from .predict import run_predict
from .stats import run_stats
from .plot import run_plot


log = logging.getLogger('snco')


@click.group()
@click.version_option()
def main():
    '''
    snco: a toolkit for performing crossover mapping from single nucleus RNA/ATAC sequencing data
    '''
    pass


def apply_options(options_list):
    'decorator to apply a list of click options at once'
    def _apply_options(func):
        for option in reversed(options_list):
            func = option(func)
        return func
    return _apply_options


def get_kwarg_subset(kw_list, kwargs):
    return {kw: kwargs[kw] for kw in kw_list}


bam2preds_options = [
    opts.bam, opts.output_prefix, opts.cb_whitelist, opts.bin_size,
    opts.seq_type, opts.cb_corr_method, opts.cb_tag,
    opts.umi_collapse_method, opts.umi_tag,
    opts.hap_tag, opts.excl_contigs,
    opts.min_markers, opts.max_bin_count,
    opts.run_clean, opts.clean_bg, opts.bg_window_size,
    opts.mask_imbalanced, opts.max_imbalance,
    opts.seg_size, opts.term_seg_size, opts.cm_per_mb, opts.model_lambdas,
    opts.precision, opts.processes, opts.batch_size, opts.device,
    opts.processes, logger.verbosity
]


@main.command('bam2pred')
@apply_options(bam2preds_options)
def bam_pipeline_subcommand(**kwargs):
    '''
    Pipeline chaining together the loadbam, clean and predict commands
    '''

    output_prefix = kwargs.pop('output_prefix')
    loadbam_kwargs = [
        'bam_fn', 'cb_whitelist_fn', 'bin_size', 'seq_type',
        'cb_correction_method', 'cb_tag',
        'umi_collapse_method', 'umi_tag', 'hap_tag',
        'exclude_contigs', 'processes'
    ]
    loadbam_kwargs = get_kwarg_subset(loadbam_kwargs, kwargs)
    loadbam_output = f'{output_prefix}.markers.json'
    loadbam_kwargs['output_json_fn'] = loadbam_output

    run_loadbam(**loadbam_kwargs)

    if kwargs['run_clean']:

        clean_kwargs = [
            'bin_size', 'min_markers_per_cb', 'max_bin_count',
            'clean_bg', 'bg_window_size',
            'mask_imbalanced', 'max_marker_imbalance',
        ]

        clean_kwargs = get_kwarg_subset(clean_kwargs, kwargs)
        clean_kwargs['marker_json_fn'] = loadbam_output
        clean_output = f'{output_prefix}.cmarkers.json'
        clean_kwargs['output_json_fn'] = clean_output

        run_clean(**clean_kwargs)

    else:
        clean_output = loadbam_output

    predict_kwargs = [
        'bin_size', 'segment_size', 'terminal_segment_size',
        'cm_per_mb', 'model_lambdas', 'output_precision',
        'processes', 'batch_size', 'device',
    ]
    predict_kwargs = get_kwarg_subset(predict_kwargs, kwargs)
    predict_kwargs['marker_json_fn'] = clean_output
    predict_output = f'{output_prefix}.pred.json'
    predict_kwargs['output_json_fn'] = predict_output

    run_predict(**predict_kwargs)


loadbam_options = [
    opts.bam, opts.output_json, opts.cb_whitelist, opts.bin_size,
    opts.seq_type, opts.cb_corr_method, opts.cb_tag,
    opts.umi_collapse_method, opts.umi_tag,
    opts.hap_tag, opts.excl_contigs,
    opts.processes, logger.verbosity
]

@main.command('loadbam')
@apply_options(loadbam_options)
def loadbam_subcommand(**kwargs):
    '''
    Read bam file with cell barcode, umi and haplotype tags (aligned with STAR solo+diploid), 
    to generate a json file of binned haplotype marker distributions for each cell barcode. 
    These can be used to call recombinations using the downstream `predict` command.
    '''
    run_loadbam(**kwargs)


loadcsl_options = [
    opts.csl_dir, opts.chrom_sizes, opts.output_json,
    opts.cb_whitelist, opts.bin_size,
    logger.verbosity
]


@main.command('loadcsl')
@apply_options(loadcsl_options)
def loadcsl_subcommand(**kwargs):
    '''
    Read matrix files generated by cell snp lite to generate a json file of binned
    haplotype marker distributions for each cell barcode. These can be used to
    call recombinations using the downstream `predict` command.
    '''
    run_loadcsl(**kwargs)


sim_options = [
    opts.marker_json, opts.haplo_bed, opts.output_json,
    opts.cb_whitelist, opts.bin_size,
    opts.bg_marker_rate, opts.bg_window_size, opts.nsim_per_samp,
    logger.verbosity
]


@main.command('sim')
@apply_options(sim_options)
def sim_subcommand(**kwargs):
    '''
    Simulate realistic haplotype marker distributions using real data from `load`,
    with known haplotypes/crossovers supplied from a bed file.
    '''
    run_sim(**kwargs)


concat_options = [
    opts.concat_json, opts.output_json,
    opts.merge_suffixes,
    logger.verbosity
]


@main.command('concat')
@apply_options(concat_options)
def concat_subcommand(**kwargs):
    '''
    Concatenates marker jsons, potentially from different datasets, 
    adding suffixes to cell barcodes to avoid name collisions
    '''
    run_concat(**kwargs)


clean_options = [
    opts.marker_json, opts.output_json, opts.cb_whitelist, opts.bin_size,
    opts.min_markers, opts.max_bin_count,
    opts.clean_bg, opts.bg_window_size,
    opts.mask_imbalanced, opts.max_imbalance,
    logger.verbosity
]


@main.command('clean')
@apply_options(clean_options)
def clean_subcommand(**kwargs):
    '''
    Removes predicted background markers, that result from ambient nucleic acids, 
    from each cell barcode.
    '''
    run_clean(**kwargs)


predict_options = [
    opts.marker_json, opts.output_json, opts.cb_whitelist, opts.bin_size,
    opts.seg_size, opts.term_seg_size, opts.cm_per_mb, opts.model_lambdas,
    opts.precision, opts.processes, opts.batch_size, opts.device,
    logger.verbosity
]


@main.command('predict')
@apply_options(predict_options)
def predict_subcommand(**kwargs):
    '''
    Uses rigid hidden Markov model to predict the haplotypes of each cell barcode
    at each genomic bin.
    '''
    run_predict(**kwargs)

stats_options = [
    opts.marker_json, opts.pred_json, opts.output_tsv,
    opts.cb_whitelist, opts.bin_size,
    opts.precision, logger.verbosity
]


@main.command('stats')
@apply_options(stats_options)
def stats_subcommand(**kwargs):
    '''
    Scores the quality of data and predictions for a set of haplotype calls
    generated with `predict`.
    '''
    run_stats(**kwargs)


plot_options = [
    opts.cell_barcode, opts.marker_json, opts.plot_pred_json, opts.output_fig,
    opts.figsize, opts.show_pred, opts.show_co_num, opts.max_yheight,
    opts.ref_colour, opts.alt_colour,
    logger.verbosity
]


@main.command('plot')
@apply_options(plot_options)
def plot_subcommand(**kwargs):
    '''
    Draw a marker plot for a given cell barcode
    '''
    run_plot(**kwargs)


if __name__ == '__main__':
    main()
